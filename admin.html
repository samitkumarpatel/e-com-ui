<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>E-Commerce Admin</title>
  
  <!-- Material-UI Fonts and Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
  
  <!-- React and Related Libraries -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Redux Toolkit and React-Redux -->
  <script src="https://unpkg.com/@reduxjs/toolkit@1.9.5/dist/redux-toolkit.umd.js"></script>
  <script src="https://unpkg.com/react-redux@8.1.2/dist/react-redux.min.js"></script>
  
  <!-- Material-UI -->
  <script src="https://unpkg.com/@mui/material@5.14.5/umd/material-ui.production.min.js"></script>
  <script src="https://unpkg.com/@emotion/react@11.11.1/dist/emotion-react.umd.min.js"></script>
  <script src="https://unpkg.com/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>
  
  <style>
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #f5f5f5;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect } = React;
    const { useSelector, useDispatch, Provider } = ReactRedux;
    const { configureStore, createSlice } = RTK;
    const { 
      Box, 
      Container, 
      Typography, 
      Button, 
      Card, 
      CardContent, 
      TextField, 
      Grid, 
      AppBar, 
      Toolbar, 
      Paper,
      ThemeProvider,
      createTheme,
      CssBaseline,
      Fab,
      Dialog,
      DialogTitle,
      DialogContent,
      DialogActions,
      List,
      ListItem,
      ListItemText,
      Chip,
      IconButton,
      Pagination,
      Menu,
      MenuItem,
      Divider,
      Alert,
      Snackbar
    } = MaterialUI;

    // Categories Slice
    const categoriesSlice = createSlice({
      name: 'categories',
      initialState: [
        { id: 1, name: 'Electronics', description: 'Electronic devices and gadgets' },
        { id: 2, name: 'Clothing', description: 'Fashion and apparel' }
      ],
      reducers: {
        addCategory: (state, action) => {
          state.push({ ...action.payload, id: Date.now() });
        },
        updateCategory: (state, action) => {
          const index = state.findIndex(cat => cat.id === action.payload.id);
          if (index !== -1) {
            state[index] = action.payload;
          }
        },
        deleteCategory: (state, action) => {
          return state.filter(cat => cat.id !== action.payload);
        }
      }
    });

    // Products Slice
    const productsSlice = createSlice({
      name: 'products',
      initialState: [
        { id: 1, name: 'Smartphone', description: 'Latest model smartphone', price: 699.99, quantity: 50, categoryId: 1 },
        { id: 2, name: 'T-Shirt', description: 'Cotton casual t-shirt', price: 24.99, quantity: 100, categoryId: 2 }
      ],
      reducers: {
        addProduct: (state, action) => {
          state.push({ ...action.payload, id: Date.now() });
        },
        updateProduct: (state, action) => {
          const index = state.findIndex(prod => prod.id === action.payload.id);
          if (index !== -1) {
            state[index] = action.payload;
          }
        },
        deleteProduct: (state, action) => {
          return state.filter(prod => prod.id !== action.payload);
        },
        deleteProductsByCategory: (state, action) => {
          return state.filter(prod => prod.categoryId !== action.payload);
        }
      }
    });

    // UI Slice for managing dialog states
    const uiSlice = createSlice({
      name: 'ui',
      initialState: {
        categoryDialogOpen: false,
        productDialogOpen: false,
        selectedCategoryId: null,
        showCategoryProducts: false,
        editingCategory: null,
        editingProduct: null,
        snackbar: { open: false, message: '', severity: 'success' }
      },
      reducers: {
        setCategoryDialog: (state, action) => {
          state.categoryDialogOpen = action.payload;
          if (!action.payload) {
            state.editingCategory = null;
          }
        },
        setProductDialog: (state, action) => {
          state.productDialogOpen = action.payload;
          if (!action.payload) {
            state.editingProduct = null;
          }
        },
        setSelectedCategory: (state, action) => {
          state.selectedCategoryId = action.payload;
          state.showCategoryProducts = action.payload !== null;
        },
        clearSelectedCategory: (state) => {
          state.selectedCategoryId = null;
          state.showCategoryProducts = false;
        },
        setEditingCategory: (state, action) => {
          state.editingCategory = action.payload;
          state.categoryDialogOpen = true;
        },
        setEditingProduct: (state, action) => {
          state.editingProduct = action.payload;
          state.productDialogOpen = true;
        },
        showSnackbar: (state, action) => {
          state.snackbar = { open: true, ...action.payload };
        },
        hideSnackbar: (state) => {
          state.snackbar.open = false;
        }
      }
    });

    // Export actions
    const { addCategory, updateCategory, deleteCategory } = categoriesSlice.actions;
    const { addProduct, updateProduct, deleteProduct, deleteProductsByCategory } = productsSlice.actions;
    const { setCategoryDialog, setProductDialog, setSelectedCategory, clearSelectedCategory, setEditingCategory, setEditingProduct, showSnackbar, hideSnackbar } = uiSlice.actions;

    // Configure Store
    const store = configureStore({
      reducer: {
        categories: categoriesSlice.reducer,
        products: productsSlice.reducer,
        ui: uiSlice.reducer
      }
    });

    // Create Material-UI theme
    const theme = createTheme({
      palette: {
        primary: {
          main: '#1976d2',
        },
        secondary: {
          main: '#dc004e',
        },
        background: {
          default: '#f5f5f5',
        },
      },
    });

    // Category Form Component
    const CategoryForm = () => {
      const dispatch = useDispatch();
      const { categoryDialogOpen, editingCategory } = useSelector(state => state.ui);
      const [formData, setFormData] = useState({ name: '', description: '' });
      const [errors, setErrors] = useState({});

      const isEditMode = !!editingCategory;

      // Initialize form data when editing
      useEffect(() => {
        if (editingCategory) {
          setFormData({
            name: editingCategory.name,
            description: editingCategory.description
          });
        } else {
          setFormData({ name: '', description: '' });
        }
      }, [editingCategory]);

      // Clear errors when dialog opens
      useEffect(() => {
        if (categoryDialogOpen) {
          setErrors({});
        }
      }, [categoryDialogOpen]);

      const validateForm = () => {
        const newErrors = {};

        if (!formData.name.trim()) {
          newErrors.name = 'Category name is required';
        }

        if (!formData.description.trim()) {
          newErrors.description = 'Description is required';
        }

        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
      };

      const handleSubmit = () => {
        if (validateForm()) {
          try {
            if (isEditMode) {
              dispatch(updateCategory({ ...editingCategory, ...formData }));
              dispatch(showSnackbar({ message: 'Category updated successfully!', severity: 'success' }));
            } else {
              dispatch(addCategory(formData));
              dispatch(showSnackbar({ message: 'Category added successfully!', severity: 'success' }));
            }
            setFormData({ name: '', description: '' });
            setErrors({});
            dispatch(setCategoryDialog(false));
          } catch (error) {
            console.error('Error saving category:', error);
            dispatch(showSnackbar({ message: 'Error saving category', severity: 'error' }));
          }
        }
      };

      const handleClose = () => {
        setFormData({ name: '', description: '' });
        setErrors({});
        dispatch(setCategoryDialog(false));
      };

      const handleInputChange = (field, value) => {
        setFormData(prev => ({ ...prev, [field]: value }));
        
        // Clear error for this field when user starts typing
        if (errors[field]) {
          setErrors(prev => {
            const newErrors = { ...prev };
            delete newErrors[field];
            return newErrors;
          });
        }
      };

      return (
        <Dialog 
          open={categoryDialogOpen} 
          onClose={handleClose} 
          maxWidth="sm" 
          fullWidth
          disablePortal={false}
          keepMounted={false}
          aria-labelledby="category-dialog-title"
          aria-describedby="category-dialog-description"
        >
          <DialogTitle id="category-dialog-title">
            {isEditMode ? 'Edit Category' : 'Add New Category'}
          </DialogTitle>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              label="Category Name"
              fullWidth
              variant="outlined"
              value={formData.name}
              onChange={(e) => handleInputChange('name', e.target.value)}
              error={!!errors.name}
              helperText={errors.name}
              sx={{ mb: 2 }}
            />
            <TextField
              margin="dense"
              label="Description"
              fullWidth
              multiline
              rows={4}
              variant="outlined"
              value={formData.description}
              onChange={(e) => handleInputChange('description', e.target.value)}
              error={!!errors.description}
              helperText={errors.description}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={handleClose}>Cancel</Button>
            <Button 
              onClick={handleSubmit} 
              variant="contained"
              disabled={!formData.name.trim() || !formData.description.trim()}
            >
              {isEditMode ? 'Update Category' : 'Add Category'}
            </Button>
          </DialogActions>
        </Dialog>
      );
    };

    // Product Form Component
    const ProductForm = () => {
      const dispatch = useDispatch();
      const { productDialogOpen, selectedCategoryId, editingProduct } = useSelector(state => state.ui);
      const categories = useSelector(state => state.categories);
      const [formData, setFormData] = useState({ 
        name: '', 
        description: '', 
        price: '', 
        quantity: '', 
        categoryId: selectedCategoryId || '' 
      });
      const [errors, setErrors] = useState({});

      const isEditMode = !!editingProduct;

      // Initialize form data when editing
      useEffect(() => {
        if (editingProduct) {
          setFormData({
            name: editingProduct.name,
            description: editingProduct.description,
            price: editingProduct.price.toString(),
            quantity: editingProduct.quantity.toString(),
            categoryId: editingProduct.categoryId.toString()
          });
        } else {
          const resetCategoryId = selectedCategoryId ? selectedCategoryId.toString() : '';
          setFormData({ 
            name: '', 
            description: '', 
            price: '', 
            quantity: '', 
            categoryId: resetCategoryId 
          });
        }
      }, [editingProduct, selectedCategoryId]);

      // Update categoryId when selectedCategoryId changes (only for new products)
      useEffect(() => {
        if (!isEditMode && selectedCategoryId && selectedCategoryId !== formData.categoryId) {
          setFormData(prev => ({ ...prev, categoryId: selectedCategoryId.toString() }));
        }
      }, [selectedCategoryId, formData.categoryId, isEditMode]);

      // Clear errors when dialog opens
      useEffect(() => {
        if (productDialogOpen) {
          setErrors({});
        }
      }, [productDialogOpen]);

      const validateForm = () => {
        const newErrors = {};

        if (!formData.name.trim()) {
          newErrors.name = 'Product name is required';
        }

        if (!formData.description.trim()) {
          newErrors.description = 'Description is required';
        }

        if (!formData.price || parseFloat(formData.price) <= 0) {
          newErrors.price = 'Price must be greater than 0';
        }

        if (!formData.quantity || parseInt(formData.quantity) <= 0) {
          newErrors.quantity = 'Quantity must be greater than 0';
        }

        if (!formData.categoryId) {
          newErrors.categoryId = 'Category is required';
        }

        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
      };

      const handleSubmit = () => {
        if (validateForm()) {
          try {
            const productData = {
              ...formData,
              price: parseFloat(formData.price),
              quantity: parseInt(formData.quantity),
              categoryId: parseInt(formData.categoryId)
            };

            if (isEditMode) {
              dispatch(updateProduct({ ...editingProduct, ...productData }));
              dispatch(showSnackbar({ message: 'Product updated successfully!', severity: 'success' }));
            } else {
              dispatch(addProduct(productData));
              dispatch(showSnackbar({ message: 'Product added successfully!', severity: 'success' }));
            }
            
            // Reset form
            const resetCategoryId = selectedCategoryId ? selectedCategoryId.toString() : '';
            setFormData({ 
              name: '', 
              description: '', 
              price: '', 
              quantity: '', 
              categoryId: resetCategoryId 
            });
            setErrors({});
            dispatch(setProductDialog(false));
          } catch (error) {
            console.error('Error saving product:', error);
            dispatch(showSnackbar({ message: 'Error saving product', severity: 'error' }));
          }
        }
      };

      const handleClose = () => {
        const resetCategoryId = selectedCategoryId ? selectedCategoryId.toString() : '';
        setFormData({ 
          name: '', 
          description: '', 
          price: '', 
          quantity: '', 
          categoryId: resetCategoryId 
        });
        setErrors({});
        dispatch(setProductDialog(false));
      };

      const handleInputChange = (field, value) => {
        setFormData(prev => ({ ...prev, [field]: value }));
        
        // Clear error for this field when user starts typing
        if (errors[field]) {
          setErrors(prev => {
            const newErrors = { ...prev };
            delete newErrors[field];
            return newErrors;
          });
        }
      };

      return (
        <Dialog 
          open={productDialogOpen} 
          onClose={handleClose} 
          maxWidth="sm" 
          fullWidth
          disablePortal={false}
          keepMounted={false}
          aria-labelledby="product-dialog-title"
          aria-describedby="product-dialog-description"
        >
          <DialogTitle id="product-dialog-title">
            {isEditMode ? 'Edit Product' : 'Add New Product'}
          </DialogTitle>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              label="Product Name"
              fullWidth
              variant="outlined"
              value={formData.name}
              onChange={(e) => handleInputChange('name', e.target.value)}
              error={!!errors.name}
              helperText={errors.name}
              sx={{ mb: 2 }}
            />
            <TextField
              margin="dense"
              label="Description"
              fullWidth
              multiline
              rows={3}
              variant="outlined"
              value={formData.description}
              onChange={(e) => handleInputChange('description', e.target.value)}
              error={!!errors.description}
              helperText={errors.description}
              sx={{ mb: 2 }}
            />
            <Grid container spacing={2} sx={{ mb: 2 }}>
              <Grid item xs={6}>
                <TextField
                  label="Price"
                  type="number"
                  step="0.01"
                  fullWidth
                  variant="outlined"
                  value={formData.price}
                  onChange={(e) => handleInputChange('price', e.target.value)}
                  error={!!errors.price}
                  helperText={errors.price}
                  inputProps={{ min: "0", step: "0.01" }}
                />
              </Grid>
              <Grid item xs={6}>
                <TextField
                  label="Quantity"
                  type="number"
                  fullWidth
                  variant="outlined"
                  value={formData.quantity}
                  onChange={(e) => handleInputChange('quantity', e.target.value)}
                  error={!!errors.quantity}
                  helperText={errors.quantity}
                  inputProps={{ min: "1", step: "1" }}
                />
              </Grid>
            </Grid>
            <TextField
              select
              label="Category"
              fullWidth
              variant="outlined"
              value={formData.categoryId}
              onChange={(e) => handleInputChange('categoryId', e.target.value)}
              error={!!errors.categoryId}
              helperText={errors.categoryId}
              SelectProps={{ native: true }}
            >
              <option value="">Select a category</option>
              {categories.map((category) => (
                <option key={category.id} value={category.id.toString()}>
                  {category.name}
                </option>
              ))}
            </TextField>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleClose}>Cancel</Button>
            <Button 
              onClick={handleSubmit} 
              variant="contained" 
              color="secondary"
              disabled={!formData.name.trim() || !formData.description.trim() || !formData.price || !formData.quantity || !formData.categoryId}
            >
              {isEditMode ? 'Update Product' : 'Add Product'}
            </Button>
          </DialogActions>
        </Dialog>
      );
    };

    // Dashboard Stats Component
    const DashboardStats = () => {
      const categories = useSelector(state => state.categories);
      const products = useSelector(state => state.products);

      const totalStock = products.reduce((sum, prod) => sum + prod.quantity, 0);
      const avgPrice = products.length > 0 ? 
        (products.reduce((sum, prod) => sum + prod.price, 0) / products.length).toFixed(2) : '0.00';

      return (
        <Grid container spacing={3} sx={{ mb: 4 }}>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Total Categories
                </Typography>
                <Typography variant="h4" component="h2" color="primary">
                  {categories.length}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Total Products
                </Typography>
                <Typography variant="h4" component="h2" color="secondary">
                  {products.length}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Total Stock
                </Typography>
                <Typography variant="h4" component="h2" color="success.main">
                  {totalStock}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Avg Price
                </Typography>
                <Typography variant="h4" component="h2" color="warning.main">
                  ${avgPrice}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      );
    };

    // Categories Section Component
    const CategoriesSection = () => {
      const dispatch = useDispatch();
      const categories = useSelector(state => state.categories);
      const products = useSelector(state => state.products);
      const { selectedCategoryId } = useSelector(state => state.ui);

      const handleCategoryClick = (categoryId) => {
        dispatch(setSelectedCategory(categoryId));
      };

      const handleEditCategory = (event, category) => {
        event.stopPropagation();
        dispatch(setEditingCategory(category));
      };

      const handleDeleteCategory = (event, category) => {
        event.stopPropagation();
        const productsInCategory = products.filter(p => p.categoryId === category.id);
        
        if (productsInCategory.length > 0) {
          if (window.confirm(`This category contains ${productsInCategory.length} product(s). Are you sure you want to delete it? All products in this category will also be deleted.`)) {
            dispatch(deleteProductsByCategory(category.id));
            dispatch(deleteCategory(category.id));
            dispatch(showSnackbar({ message: 'Category and associated products deleted successfully!', severity: 'success' }));
            
            // Clear selection if deleted category was selected
            if (selectedCategoryId === category.id) {
              dispatch(clearSelectedCategory());
            }
          }
        } else {
          if (window.confirm('Are you sure you want to delete this category?')) {
            dispatch(deleteCategory(category.id));
            dispatch(showSnackbar({ message: 'Category deleted successfully!', severity: 'success' }));
            
            // Clear selection if deleted category was selected
            if (selectedCategoryId === category.id) {
              dispatch(clearSelectedCategory());
            }
          }
        }
      };

      return (
        <Paper sx={{ p: 3, mb: 3 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h5" component="h2">
              Categories
            </Typography>
            <Button 
              variant="contained" 
              onClick={() => dispatch(setCategoryDialog(true))}
              startIcon={<span className="material-icons">add</span>}
            >
              Add Category
            </Button>
          </Box>
          
          <Grid container spacing={2}>
            {categories.map((category) => (
              <Grid item xs={12} sm={6} md={4} key={category.id}>
                <Card 
                  variant="outlined"
                  sx={{ 
                    cursor: 'pointer',
                    transition: 'all 0.2s ease-in-out',
                    transform: selectedCategoryId === category.id ? 'scale(1.02)' : 'scale(1)',
                    boxShadow: selectedCategoryId === category.id ? 3 : 1,
                    borderColor: selectedCategoryId === category.id ? 'primary.main' : 'grey.300',
                    '&:hover': {
                      transform: 'scale(1.02)',
                      boxShadow: 3
                    }
                  }}
                  onClick={() => handleCategoryClick(category.id)}
                >
                  <CardContent>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                      <Box sx={{ flex: 1 }}>
                        <Typography variant="h6" component="h3">
                          {category.name}
                        </Typography>
                        <Typography color="textSecondary">
                          {category.description}
                        </Typography>
                      </Box>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        {selectedCategoryId === category.id && (
                          <Chip 
                            label="Selected" 
                            color="primary" 
                            size="small"
                          />
                        )}
                        <IconButton 
                          size="small" 
                          onClick={(e) => handleEditCategory(e, category)}
                          sx={{ color: 'primary.main' }}
                        >
                          <span className="material-icons" style={{ fontSize: '18px' }}>edit</span>
                        </IconButton>
                        <IconButton 
                          size="small" 
                          onClick={(e) => handleDeleteCategory(e, category)}
                          sx={{ color: 'error.main' }}
                        >
                          <span className="material-icons" style={{ fontSize: '18px' }}>delete</span>
                        </IconButton>
                      </Box>
                    </Box>
                    <Typography variant="caption" color="primary" sx={{ mt: 1, display: 'block' }}>
                      Click to view products
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>
            ))}
          </Grid>
        </Paper>
      );
    };

    // Products Section Component
    const ProductsSection = () => {
      const dispatch = useDispatch();
      const products = useSelector(state => state.products);
      const categories = useSelector(state => state.categories);
      const { selectedCategoryId, showCategoryProducts } = useSelector(state => state.ui);
      
      // Pagination state
      const [currentPage, setCurrentPage] = useState(1);
      const [productsPerPage] = useState(6); // 6 products per page (2 rows of 3 cards)

      const getCategoryName = (categoryId) => {
        const category = categories.find(cat => cat.id === categoryId);
        return category ? category.name : 'Unknown';
      };

      const getSelectedCategoryName = () => {
        if (selectedCategoryId) {
          const category = categories.find(cat => cat.id === selectedCategoryId);
          return category ? category.name : 'Unknown Category';
        }
        return '';
      };

      // Filter products based on selected category
      const filteredProducts = showCategoryProducts 
        ? products.filter(product => product.categoryId === selectedCategoryId)
        : products;

      // Calculate pagination
      const totalPages = Math.ceil(filteredProducts.length / productsPerPage);
      const startIndex = (currentPage - 1) * productsPerPage;
      const endIndex = startIndex + productsPerPage;
      const displayProducts = filteredProducts.slice(startIndex, endIndex);

      // Reset to first page when category changes
      useEffect(() => {
        setCurrentPage(1);
      }, [selectedCategoryId, showCategoryProducts]);

      const handlePageChange = (event, page) => {
        setCurrentPage(page);
      };

      const handleAddProduct = () => {
        dispatch(setProductDialog(true));
      };

      const handleBackToAllProducts = () => {
        dispatch(clearSelectedCategory());
      };

      const handleEditProduct = (product) => {
        dispatch(setEditingProduct(product));
      };

      const handleDeleteProduct = (product) => {
        if (window.confirm('Are you sure you want to delete this product?')) {
          dispatch(deleteProduct(product.id));
          dispatch(showSnackbar({ message: 'Product deleted successfully!', severity: 'success' }));
        }
      };

      return (
        <Paper sx={{ p: 3 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              <Typography variant="h5" component="h2">
                {showCategoryProducts ? `${getSelectedCategoryName()} Products` : 'All Products'}
              </Typography>
              {showCategoryProducts && (
                <Button 
                  variant="outlined" 
                  size="small"
                  onClick={handleBackToAllProducts}
                  startIcon={<span className="material-icons">arrow_back</span>}
                >
                  Back to All
                </Button>
              )}
              {filteredProducts.length > 0 && (
                <Typography variant="body2" color="textSecondary">
                  {filteredProducts.length} total products
                </Typography>
              )}
            </Box>
            <Button 
              variant="contained" 
              color="secondary"
              onClick={handleAddProduct}
              startIcon={<span className="material-icons">inventory</span>}
            >
              {showCategoryProducts ? `Add to ${getSelectedCategoryName()}` : 'Add Product'}
            </Button>
          </Box>

          {filteredProducts.length === 0 ? (
            <Box sx={{ textAlign: 'center', py: 4 }}>
              <Typography variant="h6" color="textSecondary" gutterBottom>
                {showCategoryProducts ? `No products found in ${getSelectedCategoryName()}` : 'No products available'}
              </Typography>
              <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
                {showCategoryProducts ? `Start by adding some products to ${getSelectedCategoryName()}` : 'Start by adding your first product'}
              </Typography>
              <Button 
                variant="contained" 
                color="secondary"
                onClick={handleAddProduct}
                startIcon={<span className="material-icons">add</span>}
              >
                {showCategoryProducts ? `Add Product to ${getSelectedCategoryName()}` : 'Add First Product'}
              </Button>
            </Box>
          ) : (
            <Box>
              <Grid container spacing={2}>
                {displayProducts.map((product) => (
                  <Grid item xs={12} sm={6} md={4} key={product.id}>
                    <Card variant="outlined">
                      <CardContent>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                          <Typography variant="h6" component="h3" sx={{ flex: 1 }}>
                            {product.name}
                          </Typography>
                          <Box sx={{ display: 'flex', gap: 0.5 }}>
                            <IconButton 
                              size="small" 
                              onClick={() => handleEditProduct(product)}
                              sx={{ color: 'primary.main' }}
                            >
                              <span className="material-icons" style={{ fontSize: '16px' }}>edit</span>
                            </IconButton>
                            <IconButton 
                              size="small" 
                              onClick={() => handleDeleteProduct(product)}
                              sx={{ color: 'error.main' }}
                            >
                              <span className="material-icons" style={{ fontSize: '16px' }}>delete</span>
                            </IconButton>
                          </Box>
                        </Box>
                        <Chip 
                          label={getCategoryName(product.categoryId)} 
                          size="small" 
                          color="primary" 
                          sx={{ mb: 1 }}
                        />
                        <Typography color="textSecondary" sx={{ mb: 1 }}>
                          {product.description}
                        </Typography>
                        <Typography variant="h6" color="primary">
                          ${product.price.toFixed(2)}
                        </Typography>
                        <Typography variant="body2">
                          Stock: {product.quantity}
                        </Typography>
                      </CardContent>
                    </Card>
                  </Grid>
                ))}
              </Grid>
              
              {/* Pagination Controls */}
              {totalPages > 1 && (
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', mt: 4, gap: 2 }}>
                  <Typography variant="body2" color="textSecondary">
                    Page {currentPage} of {totalPages}
                  </Typography>
                  <Pagination 
                    count={totalPages} 
                    page={currentPage} 
                    onChange={handlePageChange}
                    color="primary"
                    size="medium"
                    showFirstButton 
                    showLastButton
                  />
                  <Typography variant="body2" color="textSecondary">
                    Showing {startIndex + 1}-{Math.min(endIndex, filteredProducts.length)} of {filteredProducts.length}
                  </Typography>
                </Box>
              )}
            </Box>
          )}
        </Paper>
      );
    };

    // Snackbar Component
    const SnackbarComponent = () => {
      const dispatch = useDispatch();
      const { snackbar } = useSelector(state => state.ui);

      const handleClose = () => {
        dispatch(hideSnackbar());
      };

      return (
        <Snackbar
          open={snackbar.open}
          autoHideDuration={4000}
          onClose={handleClose}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        >
          <Alert onClose={handleClose} severity={snackbar.severity} sx={{ width: '100%' }}>
            {snackbar.message}
          </Alert>
        </Snackbar>
      );
    };

    // Main App Component
    const MyApp = () => {
      return (
        <ThemeProvider theme={theme}>
          <CssBaseline />
          <div id="main-content">
            <Box sx={{ flexGrow: 1 }}>
            {/* App Bar */}
            <AppBar position="static" sx={{ mb: 0 }}>
              <Container maxWidth="lg">
                <Toolbar>
                  <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
                    E-Commerce Admin
                  </Typography>
                </Toolbar>
              </Container>
            </AppBar>

            <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
              {/* Dashboard Stats */}
              <DashboardStats />

              {/* Categories Section */}
              <CategoriesSection />

              {/* Products Section */}
              <ProductsSection />

              {/* Forms */}
              <CategoryForm />
              <ProductForm />

              {/* Snackbar for notifications */}
              <SnackbarComponent />
            </Container>
          </Box>
          </div>
        </ThemeProvider>
      );
    };

    // App with Redux Provider
    const App = () => (
      <Provider store={store}>
        <MyApp />
      </Provider>
    );

    // Render the App
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
