<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>E-Commerce Admin</title>
  
  <!-- Material-UI Fonts and Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
  
  <!-- React and Related Libraries -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Redux Toolkit and React-Redux -->
  <script src="https://unpkg.com/@reduxjs/toolkit@1.9.5/dist/redux-toolkit.umd.js"></script>
  <script src="https://unpkg.com/react-redux@8.1.2/dist/react-redux.min.js"></script>
  
  <!-- Material-UI -->
  <script src="https://unpkg.com/@mui/material@5.14.5/umd/material-ui.production.min.js"></script>
  <script src="https://unpkg.com/@emotion/react@11.11.1/dist/emotion-react.umd.min.js"></script>
  <script src="https://unpkg.com/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>
  
  <style>
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #f5f5f5;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect } = React;
    const { useSelector, useDispatch, Provider } = ReactRedux;
    const { configureStore, createSlice, createAsyncThunk } = RTK;
    const { 
      Box, 
      Container, 
      Typography, 
      Button, 
      Card, 
      CardContent, 
      TextField, 
      Grid, 
      AppBar, 
      Toolbar, 
      Paper,
      ThemeProvider,
      createTheme,
      CssBaseline,
      Fab,
      Dialog,
      DialogTitle,
      DialogContent,
      DialogActions,
      List,
      ListItem,
      ListItemText,
      Chip,
      IconButton,
      Pagination,
      Menu,
      MenuItem,
      Divider,
      Alert,
      Snackbar
    } = MaterialUI;

    // API Configuration
    const API_BASE_URL = 'http://localhost:8080';

    // Category API Async Thunks
    const fetchCategories = createAsyncThunk(
      'categories/fetchCategories',
      async (_, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    const createCategory = createAsyncThunk(
      'categories/createCategory',
      async (categoryData, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(categoryData)
          });
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    const fetchCategoryById = createAsyncThunk(
      'categories/fetchCategoryById',
      async (categoryId, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category/${categoryId}`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    const updateCategoryAPI = createAsyncThunk(
      'categories/updateCategory',
      async ({ id, ...categoryData }, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category/${id}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(categoryData)
          });
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          return { id, ...data };
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    const deleteCategoryAPI = createAsyncThunk(
      'categories/deleteCategory',
      async (categoryId, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category/${categoryId}`, {
            method: 'DELETE'
          });
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return categoryId;
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    // Product API Async Thunks
    const fetchProducts = createAsyncThunk(
      'products/fetchProducts',
      async (_, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/products`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    const fetchProductsByCategory = createAsyncThunk(
      'products/fetchProductsByCategory',
      async (categoryId, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category/${categoryId}/product`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    const createProduct = createAsyncThunk(
      'products/createProduct',
      async ({ categoryId, productData }, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category/${categoryId}/product`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(productData)
          });
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    const fetchProductById = createAsyncThunk(
      'products/fetchProductById',
      async ({ categoryId, productId }, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category/${categoryId}/product/${productId}`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    const updateProductAPI = createAsyncThunk(
      'products/updateProduct',
      async ({ categoryId, productId, productData }, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category/${categoryId}/product/${productId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(productData)
          });
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          return data;
        } catch (error) {
          return rejectWithValue(error.message);
        }
      }
    );

    const deleteProductAPI = createAsyncThunk(
      'products/deleteProduct',
      async ({ categoryId, productId }, { rejectWithValue }) => {
        try {
          const response = await fetch(`${API_BASE_URL}/category/${categoryId}/product/${productId}`, {
            method: 'DELETE'
          });
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return productId;
        } catch (error) {
            return rejectWithValue(error.message);
        }
      }
    );

    // Categories Slice
    const categoriesSlice = createSlice({
      name: 'categories',
      initialState: {
        items: [],
        loading: false,
        error: null,
        selectedCategoryDetails: null
      },
      reducers: {
        clearError: (state) => {
          state.error = null;
        },
        clearSelectedCategoryDetails: (state) => {
          state.selectedCategoryDetails = null;
        }
      },
      extraReducers: (builder) => {
        builder
          // Fetch Categories
          .addCase(fetchCategories.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(fetchCategories.fulfilled, (state, action) => {
            state.loading = false;
            state.items = action.payload;
          })
          .addCase(fetchCategories.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          })
          // Create Category
          .addCase(createCategory.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(createCategory.fulfilled, (state, action) => {
            state.loading = false;
            state.items.push(action.payload);
          })
          .addCase(createCategory.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          })
          // Fetch Category by ID
          .addCase(fetchCategoryById.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(fetchCategoryById.fulfilled, (state, action) => {
            state.loading = false;
            state.selectedCategoryDetails = action.payload;
          })
          .addCase(fetchCategoryById.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          })
          // Update Category
          .addCase(updateCategoryAPI.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(updateCategoryAPI.fulfilled, (state, action) => {
            state.loading = false;
            const index = state.items.findIndex(cat => cat.id === action.payload.id);
            if (index !== -1) {
              state.items[index] = action.payload;
            }
          })
          .addCase(updateCategoryAPI.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          })
          // Delete Category
          .addCase(deleteCategoryAPI.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(deleteCategoryAPI.fulfilled, (state, action) => {
            state.loading = false;
            state.items = state.items.filter(cat => cat.id !== action.payload);
          })
          .addCase(deleteCategoryAPI.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          });
      }
    });

    // Products Slice
    const productsSlice = createSlice({
      name: 'products',
      initialState: {
        items: [],
        loading: false,
        error: null,
        selectedProductDetails: null
      },
      reducers: {
        clearProductError: (state) => {
          state.error = null;
        },
        clearSelectedProductDetails: (state) => {
          state.selectedProductDetails = null;
        },
        deleteProductsByCategory: (state, action) => {
          state.items = state.items.filter(prod => prod.category !== action.payload);
        }
      },
      extraReducers: (builder) => {
        builder
          // Fetch All Products
          .addCase(fetchProducts.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(fetchProducts.fulfilled, (state, action) => {
            state.loading = false;
            state.items = action.payload;
          })
          .addCase(fetchProducts.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          })
          // Fetch Products by Category
          .addCase(fetchProductsByCategory.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(fetchProductsByCategory.fulfilled, (state, action) => {
            state.loading = false;
            // Update or add products from this category
            const newProducts = action.payload;
            // Remove existing products from this category and add the new ones
            const otherProducts = state.items.filter(p => p.category !== newProducts[0]?.category);
            state.items = [...otherProducts, ...newProducts];
          })
          .addCase(fetchProductsByCategory.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          })
          // Create Product
          .addCase(createProduct.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(createProduct.fulfilled, (state, action) => {
            state.loading = false;
            state.items.push(action.payload);
          })
          .addCase(createProduct.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          })
          // Fetch Product by ID
          .addCase(fetchProductById.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(fetchProductById.fulfilled, (state, action) => {
            state.loading = false;
            state.selectedProductDetails = action.payload;
          })
          .addCase(fetchProductById.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          })
          // Update Product
          .addCase(updateProductAPI.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(updateProductAPI.fulfilled, (state, action) => {
            state.loading = false;
            const index = state.items.findIndex(prod => prod.id === action.payload.id);
            if (index !== -1) {
              state.items[index] = action.payload;
            }
          })
          .addCase(updateProductAPI.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          })
          // Delete Product
          .addCase(deleteProductAPI.pending, (state) => {
            state.loading = true;
            state.error = null;
          })
          .addCase(deleteProductAPI.fulfilled, (state, action) => {
            state.loading = false;
            state.items = state.items.filter(prod => prod.id !== action.payload);
          })
          .addCase(deleteProductAPI.rejected, (state, action) => {
            state.loading = false;
            state.error = action.payload;
          });
      }
    });

    // UI Slice for managing dialog states
    const uiSlice = createSlice({
      name: 'ui',
      initialState: {
        categoryDialogOpen: false,
        productDialogOpen: false,
        selectedCategoryId: null,
        showCategoryProducts: false,
        editingCategory: null,
        editingProduct: null,
        snackbar: { open: false, message: '', severity: 'success' }
      },
      reducers: {
        setCategoryDialog: (state, action) => {
          state.categoryDialogOpen = action.payload;
          if (!action.payload) {
            state.editingCategory = null;
          }
        },
        setProductDialog: (state, action) => {
          state.productDialogOpen = action.payload;
          if (!action.payload) {
            state.editingProduct = null;
          }
        },
        setSelectedCategory: (state, action) => {
          state.selectedCategoryId = action.payload;
          state.showCategoryProducts = action.payload !== null;
        },
        clearSelectedCategory: (state) => {
          state.selectedCategoryId = null;
          state.showCategoryProducts = false;
        },
        setEditingCategory: (state, action) => {
          state.editingCategory = action.payload;
          state.categoryDialogOpen = true;
        },
        setEditingProduct: (state, action) => {
          state.editingProduct = action.payload;
          state.productDialogOpen = true;
        },
        showSnackbar: (state, action) => {
          state.snackbar = { open: true, ...action.payload };
        },
        hideSnackbar: (state) => {
          state.snackbar.open = false;
        }
      }
    });

    // Export actions
    const { clearError, clearSelectedCategoryDetails } = categoriesSlice.actions;
    const { clearProductError, clearSelectedProductDetails, deleteProductsByCategory } = productsSlice.actions;
    const { setCategoryDialog, setProductDialog, setSelectedCategory, clearSelectedCategory, setEditingCategory, setEditingProduct, showSnackbar, hideSnackbar } = uiSlice.actions;

    // Configure Store
    const store = configureStore({
      reducer: {
        categories: categoriesSlice.reducer,
        products: productsSlice.reducer,
        ui: uiSlice.reducer
      }
    });

    // Create Material-UI theme
    const theme = createTheme({
      palette: {
        primary: {
          main: '#1976d2',
        },
        secondary: {
          main: '#dc004e',
        },
        background: {
          default: '#f5f5f5',
        },
      },
    });

    // Category Form Component
    const CategoryForm = () => {
      const dispatch = useDispatch();
      const { categoryDialogOpen, editingCategory } = useSelector(state => state.ui);
      const { loading, error } = useSelector(state => state.categories);
      const [formData, setFormData] = useState({ name: '', description: '' });
      const [errors, setErrors] = useState({});

      const isEditMode = !!editingCategory;

      // Initialize form data when editing
      useEffect(() => {
        if (editingCategory) {
          setFormData({
            name: editingCategory.name,
            description: editingCategory.description
          });
        } else {
          setFormData({ name: '', description: '' });
        }
      }, [editingCategory]);

      // Clear errors when dialog opens
      useEffect(() => {
        if (categoryDialogOpen) {
          setErrors({});
          dispatch(clearError());
        }
      }, [categoryDialogOpen, dispatch]);

      // Handle API errors
      useEffect(() => {
        if (error) {
          dispatch(showSnackbar({ 
            message: `Error: ${error}`, 
            severity: 'error' 
          }));
          dispatch(clearError());
        }
      }, [error, dispatch]);

      const validateForm = () => {
        const newErrors = {};

        if (!formData.name.trim()) {
          newErrors.name = 'Category name is required';
        }

        if (!formData.description.trim()) {
          newErrors.description = 'Description is required';
        }

        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
      };

      const handleSubmit = async () => {
        if (validateForm()) {
          try {
            if (isEditMode) {
              const resultAction = await dispatch(updateCategoryAPI({ 
                id: editingCategory.id, 
                ...formData 
              }));
              if (updateCategoryAPI.fulfilled.match(resultAction)) {
                dispatch(showSnackbar({ message: 'Category updated successfully!', severity: 'success' }));
                setFormData({ name: '', description: '' });
                setErrors({});
                dispatch(setCategoryDialog(false));
              }
            } else {
              const resultAction = await dispatch(createCategory(formData));
              if (createCategory.fulfilled.match(resultAction)) {
                dispatch(showSnackbar({ message: 'Category added successfully!', severity: 'success' }));
                setFormData({ name: '', description: '' });
                setErrors({});
                dispatch(setCategoryDialog(false));
              }
            }
          } catch (error) {
            console.error('Error saving category:', error);
          }
        }
      };

      const handleClose = () => {
        setFormData({ name: '', description: '' });
        setErrors({});
        dispatch(setCategoryDialog(false));
      };

      const handleInputChange = (field, value) => {
        setFormData(prev => ({ ...prev, [field]: value }));
        
        // Clear error for this field when user starts typing
        if (errors[field]) {
          setErrors(prev => {
            const newErrors = { ...prev };
            delete newErrors[field];
            return newErrors;
          });
        }
      };

      return (
        <Dialog 
          open={categoryDialogOpen} 
          onClose={handleClose} 
          maxWidth="sm" 
          fullWidth
          disablePortal={false}
          keepMounted={false}
          aria-labelledby="category-dialog-title"
          aria-describedby="category-dialog-description"
        >
          <DialogTitle id="category-dialog-title">
            {isEditMode ? 'Edit Category' : 'Add New Category'}
          </DialogTitle>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              label="Category Name"
              fullWidth
              variant="outlined"
              value={formData.name}
              onChange={(e) => handleInputChange('name', e.target.value)}
              error={!!errors.name}
              helperText={errors.name}
              sx={{ mb: 2 }}
            />
            <TextField
              margin="dense"
              label="Description"
              fullWidth
              multiline
              rows={4}
              variant="outlined"
              value={formData.description}
              onChange={(e) => handleInputChange('description', e.target.value)}
              error={!!errors.description}
              helperText={errors.description}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={handleClose}>Cancel</Button>
            <Button 
              onClick={handleSubmit} 
              variant="contained"
              disabled={!formData.name.trim() || !formData.description.trim() || loading}
            >
              {loading ? 'Saving...' : (isEditMode ? 'Update Category' : 'Add Category')}
            </Button>
          </DialogActions>
        </Dialog>
      );
    };

    // Product Form Component
    const ProductForm = () => {
      const dispatch = useDispatch();
      const { productDialogOpen, selectedCategoryId, editingProduct } = useSelector(state => state.ui);
      const { items: categories } = useSelector(state => state.categories);
      const { loading: productLoading, error: productError } = useSelector(state => state.products);
      const [formData, setFormData] = useState({ 
        name: '', 
        description: '', 
        price: '', 
        quantity: '', 
        categoryId: selectedCategoryId || '' 
      });
      const [errors, setErrors] = useState({});

      const isEditMode = !!editingProduct;

      // Initialize form data when editing
      useEffect(() => {
        if (editingProduct) {
          setFormData({
            name: editingProduct.name,
            description: editingProduct.description,
            price: editingProduct.price.toString(),
            quantity: editingProduct.inventory.quantity.toString(),
            categoryId: editingProduct.category.toString()
          });
        } else {
          const resetCategoryId = selectedCategoryId ? selectedCategoryId.toString() : '';
          setFormData({ 
            name: '', 
            description: '', 
            price: '', 
            quantity: '', 
            categoryId: resetCategoryId 
          });
        }
      }, [editingProduct, selectedCategoryId]);

      // Update categoryId when selectedCategoryId changes (only for new products)
      useEffect(() => {
        if (!isEditMode && selectedCategoryId && selectedCategoryId !== formData.categoryId) {
          setFormData(prev => ({ ...prev, categoryId: selectedCategoryId.toString() }));
        }
      }, [selectedCategoryId, formData.categoryId, isEditMode]);

      // Clear errors when dialog opens
      useEffect(() => {
        if (productDialogOpen) {
          setErrors({});
          dispatch(clearProductError());
        }
      }, [productDialogOpen, dispatch]);

      // Handle API errors
      useEffect(() => {
        if (productError) {
          dispatch(showSnackbar({ 
            message: `Error: ${productError}`, 
            severity: 'error' 
          }));
          dispatch(clearProductError());
        }
      }, [productError, dispatch]);

      const validateForm = () => {
        const newErrors = {};

        if (!formData.name.trim()) {
          newErrors.name = 'Product name is required';
        }

        if (!formData.description.trim()) {
          newErrors.description = 'Description is required';
        }

        if (!formData.price || parseFloat(formData.price) <= 0) {
          newErrors.price = 'Price must be greater than 0';
        }

        if (!formData.quantity || parseInt(formData.quantity) <= 0) {
          newErrors.quantity = 'Quantity must be greater than 0';
        }

        if (!formData.categoryId) {
          newErrors.categoryId = 'Category is required';
        }

        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
      };

      const handleSubmit = async () => {
        if (validateForm()) {
          try {
            const productData = {
              name: formData.name,
              description: formData.description,
              price: parseFloat(formData.price),
              inventory: {
                quantity: parseInt(formData.quantity)
              }
            };

            if (isEditMode) {
              const resultAction = await dispatch(updateProductAPI({
                categoryId: parseInt(formData.categoryId),
                productId: editingProduct.id,
                productData
              }));
              if (updateProductAPI.fulfilled.match(resultAction)) {
                dispatch(showSnackbar({ message: 'Product updated successfully!', severity: 'success' }));
                setFormData({ 
                  name: '', 
                  description: '', 
                  price: '', 
                  quantity: '', 
                  categoryId: selectedCategoryId ? selectedCategoryId.toString() : '' 
                });
                setErrors({});
                dispatch(setProductDialog(false));
              }
            } else {
              const resultAction = await dispatch(createProduct({
                categoryId: parseInt(formData.categoryId),
                productData
              }));
              if (createProduct.fulfilled.match(resultAction)) {
                dispatch(showSnackbar({ message: 'Product added successfully!', severity: 'success' }));
                setFormData({ 
                  name: '', 
                  description: '', 
                  price: '', 
                  quantity: '', 
                  categoryId: selectedCategoryId ? selectedCategoryId.toString() : '' 
                });
                setErrors({});
                dispatch(setProductDialog(false));
              }
            }
          } catch (error) {
            console.error('Error saving product:', error);
          }
        }
      };

      const handleClose = () => {
        const resetCategoryId = selectedCategoryId ? selectedCategoryId.toString() : '';
        setFormData({ 
          name: '', 
          description: '', 
          price: '', 
          quantity: '', 
          categoryId: resetCategoryId 
        });
        setErrors({});
        dispatch(setProductDialog(false));
      };

      const handleInputChange = (field, value) => {
        setFormData(prev => ({ ...prev, [field]: value }));
        
        // Clear error for this field when user starts typing
        if (errors[field]) {
          setErrors(prev => {
            const newErrors = { ...prev };
            delete newErrors[field];
            return newErrors;
          });
        }
      };

      return (
        <Dialog 
          open={productDialogOpen} 
          onClose={handleClose} 
          maxWidth="sm" 
          fullWidth
          disablePortal={false}
          keepMounted={false}
          aria-labelledby="product-dialog-title"
          aria-describedby="product-dialog-description"
        >
          <DialogTitle id="product-dialog-title">
            {isEditMode ? 'Edit Product' : 'Add New Product'}
          </DialogTitle>
          <DialogContent>
            <TextField
              autoFocus
              margin="dense"
              label="Product Name"
              fullWidth
              variant="outlined"
              value={formData.name}
              onChange={(e) => handleInputChange('name', e.target.value)}
              error={!!errors.name}
              helperText={errors.name}
              sx={{ mb: 2 }}
            />
            <TextField
              margin="dense"
              label="Description"
              fullWidth
              multiline
              rows={3}
              variant="outlined"
              value={formData.description}
              onChange={(e) => handleInputChange('description', e.target.value)}
              error={!!errors.description}
              helperText={errors.description}
              sx={{ mb: 2 }}
            />
            <Grid container spacing={2} sx={{ mb: 2 }}>
              <Grid item xs={6}>
                <TextField
                  label="Price"
                  type="number"
                  step="0.01"
                  fullWidth
                  variant="outlined"
                  value={formData.price}
                  onChange={(e) => handleInputChange('price', e.target.value)}
                  error={!!errors.price}
                  helperText={errors.price}
                  inputProps={{ min: "0", step: "0.01" }}
                />
              </Grid>
              <Grid item xs={6}>
                <TextField
                  label="Quantity"
                  type="number"
                  fullWidth
                  variant="outlined"
                  value={formData.quantity}
                  onChange={(e) => handleInputChange('quantity', e.target.value)}
                  error={!!errors.quantity}
                  helperText={errors.quantity}
                  inputProps={{ min: "1", step: "1" }}
                />
              </Grid>
            </Grid>
            <TextField
              select
              label="Category"
              fullWidth
              variant="outlined"
              value={formData.categoryId}
              onChange={(e) => handleInputChange('categoryId', e.target.value)}
              error={!!errors.categoryId}
              helperText={errors.categoryId}
              SelectProps={{ native: true }}
            >
              <option value="">Select a category</option>
              {categories.map((category) => (
                <option key={category.id} value={category.id.toString()}>
                  {category.name}
                </option>
              ))}
            </TextField>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleClose}>Cancel</Button>
            <Button 
              onClick={handleSubmit} 
              variant="contained" 
              color="secondary"
              disabled={!formData.name.trim() || !formData.description.trim() || !formData.price || !formData.quantity || !formData.categoryId || productLoading}
            >
              {productLoading ? 'Saving...' : (isEditMode ? 'Update Product' : 'Add Product')}
            </Button>
          </DialogActions>
        </Dialog>
      );
    };

    // Dashboard Stats Component
    const DashboardStats = () => {
      const { items: categories } = useSelector(state => state.categories);
      const { items: products } = useSelector(state => state.products);

      const totalStock = products.reduce((sum, prod) => sum + prod.inventory.quantity, 0);
      const avgPrice = products.length > 0 ? 
        (products.reduce((sum, prod) => sum + prod.price, 0) / products.length).toFixed(2) : '0.00';

      return (
        <Grid container spacing={3} sx={{ mb: 4 }}>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Total Categories
                </Typography>
                <Typography variant="h4" component="h2" color="primary">
                  {categories.length}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Total Products
                </Typography>
                <Typography variant="h4" component="h2" color="secondary">
                  {products.length}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Total Stock
                </Typography>
                <Typography variant="h4" component="h2" color="success.main">
                  {totalStock}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom>
                  Avg Price
                </Typography>
                <Typography variant="h4" component="h2" color="warning.main">
                  ${avgPrice}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      );
    };

    // Categories Section Component
    const CategoriesSection = () => {
      const dispatch = useDispatch();
      const { items: categories, loading, error } = useSelector(state => state.categories);
      const products = useSelector(state => state.products);
      const { selectedCategoryId } = useSelector(state => state.ui);

      // Fetch categories on component mount
      useEffect(() => {
        dispatch(fetchCategories());
      }, [dispatch]);

      // Handle API errors
      useEffect(() => {
        if (error) {
          dispatch(showSnackbar({ 
            message: `Error loading categories: ${error}`, 
            severity: 'error' 
          }));
          dispatch(clearError());
        }
      }, [error, dispatch]);

      const handleCategoryClick = (categoryId) => {
        dispatch(setSelectedCategory(categoryId));
      };

      const handleEditCategory = (event, category) => {
        event.stopPropagation();
        dispatch(setEditingCategory(category));
      };

      const handleDeleteCategory = async (event, category) => {
        event.stopPropagation();
        const productsInCategory = products.items.filter(p => p.category === category.id);
        
        if (productsInCategory.length > 0) {
          if (window.confirm(`This category contains ${productsInCategory.length} product(s). Are you sure you want to delete it? All products in this category will also be deleted.`)) {
            try {
              const resultAction = await dispatch(deleteCategoryAPI(category.id));
              if (deleteCategoryAPI.fulfilled.match(resultAction)) {
                dispatch(deleteProductsByCategory(category.id));
                dispatch(showSnackbar({ message: 'Category and associated products deleted successfully!', severity: 'success' }));
                
                // Clear selection if deleted category was selected
                if (selectedCategoryId === category.id) {
                  dispatch(clearSelectedCategory());
                }
              }
            } catch (error) {
              console.error('Error deleting category:', error);
            }
          }
        } else {
          if (window.confirm('Are you sure you want to delete this category?')) {
            try {
              const resultAction = await dispatch(deleteCategoryAPI(category.id));
              if (deleteCategoryAPI.fulfilled.match(resultAction)) {
                dispatch(showSnackbar({ message: 'Category deleted successfully!', severity: 'success' }));
                
                // Clear selection if deleted category was selected
                if (selectedCategoryId === category.id) {
                  dispatch(clearSelectedCategory());
                }
              }
            } catch (error) {
              console.error('Error deleting category:', error);
            }
          }
        }
      };

      return (
        <Paper sx={{ p: 3, mb: 3 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h5" component="h2">
              Categories
            </Typography>
            <Box sx={{ display: 'flex', gap: 1 }}>
              <Button 
                variant="outlined"
                size="small"
                onClick={() => dispatch(fetchCategories())}
                disabled={loading}
                startIcon={<span className="material-icons">refresh</span>}
              >
                {loading ? 'Loading...' : 'Refresh'}
              </Button>
              <Button 
                variant="contained" 
                onClick={() => dispatch(setCategoryDialog(true))}
                startIcon={<span className="material-icons">add</span>}
              >
                Add Category
              </Button>
            </Box>
          </Box>
          
          {loading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
              <Typography variant="body1" color="textSecondary">
                Loading categories...
              </Typography>
            </Box>
          ) : categories.length === 0 ? (
            <Box sx={{ textAlign: 'center', py: 4 }}>
              <Typography variant="h6" color="textSecondary" gutterBottom>
                No categories available
              </Typography>
              <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
                Start by adding your first category
              </Typography>
              <Button 
                variant="contained" 
                onClick={() => dispatch(setCategoryDialog(true))}
                startIcon={<span className="material-icons">add</span>}
              >
                Add First Category
              </Button>
            </Box>
          ) : (
            <Grid container spacing={2}>
            {categories.map((category) => (
              <Grid item xs={12} sm={6} md={4} key={category.id}>
                <Card 
                  variant="outlined"
                  sx={{ 
                    cursor: 'pointer',
                    transition: 'all 0.2s ease-in-out',
                    transform: selectedCategoryId === category.id ? 'scale(1.02)' : 'scale(1)',
                    boxShadow: selectedCategoryId === category.id ? 3 : 1,
                    borderColor: selectedCategoryId === category.id ? 'primary.main' : 'grey.300',
                    '&:hover': {
                      transform: 'scale(1.02)',
                      boxShadow: 3
                    }
                  }}
                  onClick={() => handleCategoryClick(category.id)}
                >
                  <CardContent>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                      <Box sx={{ flex: 1 }}>
                        <Typography variant="h6" component="h3">
                          {category.name}
                        </Typography>
                        <Typography color="textSecondary">
                          {category.description}
                        </Typography>
                      </Box>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        {selectedCategoryId === category.id && (
                          <Chip 
                            label="Selected" 
                            color="primary" 
                            size="small"
                          />
                        )}
                        <IconButton 
                          size="small" 
                          onClick={(e) => handleEditCategory(e, category)}
                          sx={{ color: 'primary.main' }}
                        >
                          <span className="material-icons" style={{ fontSize: '18px' }}>edit</span>
                        </IconButton>
                        <IconButton 
                          size="small" 
                          onClick={(e) => handleDeleteCategory(e, category)}
                          sx={{ color: 'error.main' }}
                        >
                          <span className="material-icons" style={{ fontSize: '18px' }}>delete</span>
                        </IconButton>
                      </Box>
                    </Box>
                    <Typography variant="caption" color="primary" sx={{ mt: 1, display: 'block' }}>
                      Click to view products
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>              ))}
            </Grid>
          )}
        </Paper>
      );
    };

    // Products Section Component
    const ProductsSection = () => {
      const dispatch = useDispatch();
      const { items: products, loading: productLoading, error: productError } = useSelector(state => state.products);
      const { items: categories } = useSelector(state => state.categories);
      const { selectedCategoryId, showCategoryProducts } = useSelector(state => state.ui);
      
      // Pagination state
      const [currentPage, setCurrentPage] = useState(1);
      const [productsPerPage] = useState(6); // 6 products per page (2 rows of 3 cards)

      // Fetch products on component mount
      useEffect(() => {
        dispatch(fetchProducts());
      }, [dispatch]);

      // Handle API errors
      useEffect(() => {
        if (productError) {
          dispatch(showSnackbar({ 
            message: `Error loading products: ${productError}`, 
            severity: 'error' 
          }));
          dispatch(clearProductError());
        }
      }, [productError, dispatch]);

      const getCategoryName = (categoryId) => {
        const category = categories.find(cat => cat.id === categoryId);
        return category ? category.name : 'Unknown';
      };

      const getSelectedCategoryName = () => {
        if (selectedCategoryId) {
          const category = categories.find(cat => cat.id === selectedCategoryId);
          return category ? category.name : 'Unknown Category';
        }
        return '';
      };

      // Filter products based on selected category
      const filteredProducts = showCategoryProducts 
        ? products.filter(product => product.category === selectedCategoryId)
        : products;

      // Calculate pagination
      const totalPages = Math.ceil(filteredProducts.length / productsPerPage);
      const startIndex = (currentPage - 1) * productsPerPage;
      const endIndex = startIndex + productsPerPage;
      const displayProducts = filteredProducts.slice(startIndex, endIndex);

      // Reset to first page when category changes
      useEffect(() => {
        setCurrentPage(1);
      }, [selectedCategoryId, showCategoryProducts]);

      const handlePageChange = (event, page) => {
        setCurrentPage(page);
      };

      const handleAddProduct = () => {
        dispatch(setProductDialog(true));
      };

      const handleBackToAllProducts = () => {
        dispatch(clearSelectedCategory());
      };

      const handleEditProduct = (product) => {
        dispatch(setEditingProduct(product));
      };

      const handleDeleteProduct = async (product) => {
        if (window.confirm('Are you sure you want to delete this product?')) {
          try {
            const resultAction = await dispatch(deleteProductAPI({
              categoryId: Number(product.category),
              productId: Number(product.id)
            }));
            
            if (deleteProductAPI.fulfilled.match(resultAction)) {
              dispatch(showSnackbar({ message: 'Product deleted successfully!', severity: 'success' }));
            }
          } catch (error) {
            console.error('Error deleting product:', error);
          }
        }
      };

      return (
        <Paper sx={{ p: 3 }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              <Typography variant="h5" component="h2">
                {showCategoryProducts ? `${getSelectedCategoryName()} Products` : 'All Products'}
              </Typography>
              {showCategoryProducts && (
                <Button 
                  variant="outlined" 
                  size="small"
                  onClick={handleBackToAllProducts}
                  startIcon={<span className="material-icons">arrow_back</span>}
                >
                  Back to All
                </Button>
              )}
              {filteredProducts.length > 0 && (
                <Typography variant="body2" color="textSecondary">
                  {filteredProducts.length} total products
                </Typography>
              )}
            </Box>
            <Box sx={{ display: 'flex', gap: 1 }}>
              <Button 
                variant="outlined"
                size="small"
                onClick={() => dispatch(fetchProducts())}
                disabled={productLoading}
                startIcon={<span className="material-icons">refresh</span>}
              >
                {productLoading ? 'Loading...' : 'Refresh'}
              </Button>
              <Button 
                variant="contained" 
                color="secondary"
                onClick={handleAddProduct}
                startIcon={<span className="material-icons">inventory</span>}
              >
                {showCategoryProducts ? `Add to ${getSelectedCategoryName()}` : 'Add Product'}
              </Button>
            </Box>
          </Box>

          {filteredProducts.length === 0 ? (
            <Box sx={{ textAlign: 'center', py: 4 }}>
              <Typography variant="h6" color="textSecondary" gutterBottom>
                {showCategoryProducts ? `No products found in ${getSelectedCategoryName()}` : 'No products available'}
              </Typography>
              <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
                {showCategoryProducts ? `Start by adding some products to ${getSelectedCategoryName()}` : 'Start by adding your first product'}
              </Typography>
              <Button 
                variant="contained" 
                color="secondary"
                onClick={handleAddProduct}
                startIcon={<span className="material-icons">add</span>}
              >
                {showCategoryProducts ? `Add Product to ${getSelectedCategoryName()}` : 'Add First Product'}
              </Button>
            </Box>
          ) : (
            <Box>
              <Grid container spacing={2}>
                {displayProducts.map((product) => (
                  <Grid item xs={12} sm={6} md={4} key={product.id}>
                    <Card variant="outlined">
                      <CardContent>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                          <Typography variant="h6" component="h3" sx={{ flex: 1 }}>
                            {product.name}
                          </Typography>
                          <Box sx={{ display: 'flex', gap: 0.5 }}>
                            <IconButton 
                              size="small" 
                              onClick={() => handleEditProduct(product)}
                              sx={{ color: 'primary.main' }}
                            >
                              <span className="material-icons" style={{ fontSize: '16px' }}>edit</span>
                            </IconButton>
                            <IconButton 
                              size="small" 
                              onClick={() => handleDeleteProduct(product)}
                              sx={{ color: 'error.main' }}
                            >
                              <span className="material-icons" style={{ fontSize: '16px' }}>delete</span>
                            </IconButton>
                          </Box>
                        </Box>
                        <Chip 
                          label={product.category || 'No Category'} 
                          size="small" 
                          color="primary" 
                          sx={{ mb: 1 }}
                        />
                        <Typography color="textSecondary" sx={{ mb: 1 }}>
                          {product.description}
                        </Typography>
                        <Typography variant="h6" color="primary">
                          ${Number(product.price).toFixed(2)}
                        </Typography>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <Typography variant="body2">
                            Stock: {product.inventory?.quantity || 0}
                          </Typography>
                          <Box>
                            {Number(product.inventory?.quantity || 0) > 10 && (
                              <Chip label="In Stock" size="small" color="success" />
                            )}
                            {Number(product.inventory?.quantity || 0) <= 10 && Number(product.inventory?.quantity || 0) > 0 && (
                              <Chip label="Low Stock" size="small" color="warning" />
                            )}
                            {Number(product.inventory?.quantity || 0) === 0 && (
                              <Chip label="Out of Stock" size="small" color="error" />
                            )}
                          </Box>
                        </Box>
                      </CardContent>
                    </Card>
                  </Grid>
                ))}
              </Grid>
              
              {/* Pagination Controls */}
              {totalPages > 1 && (
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', mt: 4, gap: 2 }}>
                  <Typography variant="body2" color="textSecondary">
                    Page {currentPage} of {totalPages}
                  </Typography>
                  <Pagination 
                    count={totalPages} 
                    page={currentPage} 
                    onChange={handlePageChange}
                    color="primary"
                    size="medium"
                    showFirstButton 
                    showLastButton
                  />
                  <Typography variant="body2" color="textSecondary">
                    Showing {startIndex + 1}-{Math.min(endIndex, filteredProducts.length)} of {filteredProducts.length}
                  </Typography>
                </Box>
              )}
            </Box>
          )}
        </Paper>
      );
    };

    // Snackbar Component
    const SnackbarComponent = () => {
      const dispatch = useDispatch();
      const { snackbar } = useSelector(state => state.ui);

      const handleClose = () => {
        dispatch(hideSnackbar());
      };

      return (
        <Snackbar
          open={snackbar.open}
          autoHideDuration={4000}
          onClose={handleClose}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        >
          <Alert onClose={handleClose} severity={snackbar.severity} sx={{ width: '100%' }}>
            {snackbar.message}
          </Alert>
        </Snackbar>
      );
    };

    // API Connection Status Component
    const APIConnectionStatus = () => {
      const { loading, error } = useSelector(state => state.categories);
      const [connectionStatus, setConnectionStatus] = useState('checking');

      useEffect(() => {
        const checkConnection = async () => {
          try {
            const response = await fetch(`${API_BASE_URL}/category`);
            if (response.ok) {
              setConnectionStatus('connected');
            } else {
              setConnectionStatus('error');
            }
          } catch (error) {
            setConnectionStatus('error');
          }
        };

        checkConnection();
      }, []);

      if (connectionStatus === 'checking') {
        return (
          <Alert severity="info" sx={{ mb: 2 }}>
            Checking API connection...
          </Alert>
        );
      }

      if (connectionStatus === 'error') {
        return (
          <Alert severity="error" sx={{ mb: 2 }}>
            Unable to connect to API at {API_BASE_URL}. Please ensure the backend server is running.
          </Alert>
        );
      }

      return null;
    };

    // Main App Component
    const MyApp = () => {
      return (
        <ThemeProvider theme={theme}>
          <CssBaseline />
          <div id="main-content">
            <Box sx={{ flexGrow: 1 }}>
            {/* App Bar */}
            <AppBar position="static" sx={{ mb: 0 }}>
              <Container maxWidth="lg">
                <Toolbar>
                  <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
                    E-Commerce Admin
                  </Typography>
                </Toolbar>
              </Container>
            </AppBar>

            <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
              {/* API Connection Status */}
              <APIConnectionStatus />

              {/* Dashboard Stats */}
              <DashboardStats />

              {/* Categories Section */}
              <CategoriesSection />

              {/* Products Section */}
              <ProductsSection />

              {/* Forms */}
              <CategoryForm />
              <ProductForm />

              {/* Snackbar for notifications */}
              <SnackbarComponent />
            </Container>
          </Box>
          </div>
        </ThemeProvider>
      );
    };

    // App with Redux Provider
    const App = () => (
      <Provider store={store}>
        <MyApp />
      </Provider>
    );

    // Render the App
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
